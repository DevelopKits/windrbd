diff --git a/drbd/drbd_bitmap.c b/drbd/drbd_bitmap.c
index b675c6f..57e1af8 100644
--- a/drbd/drbd_bitmap.c
+++ b/drbd/drbd_bitmap.c
@@ -1069,8 +1069,10 @@ static void drbd_bm_endio BIO_ENDIO_ARGS(struct bio *bio, blk_status_t status)
 
 	bm_page_unlock_io(device, idx);
 
-	if (ctx->flags & BM_AIO_COPY_PAGES)
-		mempool_free(bio->bi_io_vec[0].bv_page, drbd_md_io_page_pool);
+	/* Since memory of buffer is owned by MDLs we cannot free
+	   it here. It will be freed by windrbd's IO completion
+	   routine.
+	 */
 
 	bio_put(bio);
 
@@ -1107,9 +1109,16 @@ static void bm_page_io_async(struct drbd_bm_aio_ctx *ctx, int page_nr)
 	bm_set_page_unchanged(b->bm_pages[page_nr]);
 
 	if (ctx->flags & BM_AIO_COPY_PAGES) {
-		page = mempool_alloc(drbd_md_io_page_pool, __GFP_HIGHMEM|__GFP_RECLAIM);
-		expect(device, page);
-
+		page = kmalloc(sizeof(*page), 0, 'DRBD');
+		if (page == NULL) {
+			printk(KERN_ERR "Out of memory in bm_page_io_async\n");
+			return;
+		}
+		page->addr = kmalloc(PAGE_SIZE, 0, 'DRBD');
+		if (page->addr == NULL) {
+			printk(KERN_ERR "Out of memory in bm_page_io_async page\n");
+			return;
+		}
 		page->private = b->bm_pages[page_nr]->private;
 		memcpy(page->addr, b->bm_pages[page_nr]->addr, PAGE_SIZE);
 
