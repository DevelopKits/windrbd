wdrbd-next:

TODO: Create patches for DRBD for recent changes.

TODO: Submit current sources.

TODO: Redesign of architecture.

	Currently the DRBD device is stacked atop of the low level
	Disk drivers. This way all I/O goes through the WinDRBD
	driver also that of the non-drbd drives (like C:, ...).
	An Active flag controls whether I/O is routed through
	DRBD or not.
	
	One major drawback is that once the Active flag is set
	we cannot access the lower device. This is needed however
	by drbdmeta.
	
	We want an architecture that is more close to that one
	of Linux where DRBD devices and backing devices are different
	device objects, even for the Windows kernel.

+ km/wdm.h:#define IRP_MJ_CREATE                   0x00
km/wdm.h:#define IRP_MJ_CREATE_NAMED_PIPE        0x01
+ km/wdm.h:#define IRP_MJ_CLOSE                    0x02
+ km/wdm.h:#define IRP_MJ_READ                     0x03
+ km/wdm.h:#define IRP_MJ_WRITE                    0x04
km/wdm.h:#define IRP_MJ_QUERY_INFORMATION        0x05
km/wdm.h:#define IRP_MJ_SET_INFORMATION          0x06
km/wdm.h:#define IRP_MJ_QUERY_EA                 0x07
km/wdm.h:#define IRP_MJ_SET_EA                   0x08
+ km/wdm.h:#define IRP_MJ_FLUSH_BUFFERS            0x09
km/wdm.h:#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
km/wdm.h:#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
km/wdm.h:#define IRP_MJ_DIRECTORY_CONTROL        0x0c
km/wdm.h:#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
+ km/wdm.h:#define IRP_MJ_DEVICE_CONTROL           0x0e
km/wdm.h:#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
x km/wdm.h:#define IRP_MJ_SHUTDOWN                 0x10
km/wdm.h:#define IRP_MJ_LOCK_CONTROL             0x11
+ km/wdm.h:#define IRP_MJ_CLEANUP                  0x12
km/wdm.h:#define IRP_MJ_CREATE_MAILSLOT          0x13
km/wdm.h:#define IRP_MJ_QUERY_SECURITY           0x14
km/wdm.h:#define IRP_MJ_SET_SECURITY             0x15
x km/wdm.h:#define IRP_MJ_POWER                    0x16
x km/wdm.h:#define IRP_MJ_SYSTEM_CONTROL           0x17
km/wdm.h:#define IRP_MJ_DEVICE_CHANGE            0x18
km/wdm.h:#define IRP_MJ_QUERY_QUOTA              0x19
km/wdm.h:#define IRP_MJ_SET_QUOTA                0x1a
x km/wdm.h:#define IRP_MJ_PNP                      0x1b
km/wdm.h:#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
km/wdm.h:#define IRP_MJ_MAXIMUM_FUNCTION         0x1b
km/wdm.h:#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL
km/wdm.h:#define SL_PERSISTENT_MEMORY_FIXED_MAPPING  0x20    // valid only with persistent memory device and IRP_MJ_WRITE


	TODO: allow user to pass name of symbolic link created
	(i.e. the drive letter) via drbdadm/drbdsetup/kernel

	TODO: blkdev_put isn't called on drbdadm down

	fix this one day, this is probably a DRBD9 bug. Or maybe
	it is intentional.

	INIT_WORK and schedule_work do what they say?

	Later: Currently bdput is called from within drbd_unregister_device,
	ask phil if that is ok (it should make the device invisible, which
	is what it does).

	TODO: Check if it is a network share (currently blue screens)
	Update: blue screen was something else. Should check if the
	drive letter is a network share. Unfortunately they do not
	appear in the \DosDevices directory. If we create a drive
	letter (symbolic link) in the \DosDevices it will be silently
	ignored. Warn the user if it is a network share.

	TODO: One day we want to have a more specific error message
	than Device does not have a disk config if the device or
	the drive letter already exist.

	Done: Have other device extension with only the fields we
	need.

	We now disabled mvolAddDevice (by returning NO_SUCH_DEVICE,
	else we blue screen because some verifier) so volume
	extension does not exist any more (except in non-accessible
	code). 

	Update: maybe the struct block_device should be the windows
	device extension, so we safe a intermediate data structure.

	Update: That's what we do now. While having NT kernel internal
	variables inside linux structures seems like bad design at
	first, it saves a lot of (unneccessary) work. For example
	we now have the offset and io_stat used by 
	win_generic_make_request() internally as part of the struct bio.

	Done: Next thing is to have replacment data structure so
	that attach works again (create block_device with target
	device looked up in find_target_dev). Also get I/O on
	that target dev working (used to blue screen but maybe
	it works now that we do not create a device in AddDevice())

	Update: for DRBD devices device extension is now struct
	block_device. 

	Update: after long research (and with help from a stack overflow
	kernel guru) we solved the blue screen and now do not do 
	AddDevices any more.

	Rejected: check if generic_make_request can use the ZwCreateFile
	API (instead of creating an IRP)
		I/O on the backing devices work now (again) with the
		IRP API.

	Done: remove devices in bdput destroyer.
	Implemented but cannot test it now, it is newer called from 
	drbd_destroy_device (which is also never called).
	Update: calling it now from drbd_unregister_device(). Works.

	Done: bdput in drbd_create_device on failure.

	Done: clean up code, delete commented out code.

	Done: size fix (with external meta data something destroys the
	disk size setting, so that drbdadm up / down only works once).
	Update: this doesn't happen no more.

	Done: clean up block devices created by blkdev_get_by_path().

	Done: keep an internal list of struct block_devices created
	for backing devices (so that internal meta data works again).
	and don't have more than one struct block_device per physical
	partition.

	Works now (again) with internal meta data.

	Done: DeviceControl (there are many more but those
	are the ones called when the device is opened):

Done: 0x70000: FILE_DEVICE_DISK: IOCTL_DISK_GET_DRIVE_GEOMETRY
Done: 0x7405c: FILE_DEVICE_DISK: IOCTL_DISK_GET_LENGTH_INFO
Done (but does nothing): 0x74804: FILE_DEVICE_DISK: IOCTL_DISK_MEDIA_REMOVAL
Later (maybe never): 0x70024: FILE_DEVICE_DISK: IOCTL_DISK_PERFORMANCE
Later (maybe never): 0x2d1400: FILE_DEVICE_MASS_STORAGE: IOCTL_STORAGE_QUERY_PROPERTY
Later (maybe never)0x2d0c14: FILE_DEVICE_MASS_STORAGE: IOCTL_STORAGE_GET_HOTPLUG_INFO
Later (maybe never)0x2d5190: FILE_DEVICE_MASS_STORAGE: ??

TODO: 0x70004: IOCTL_DISK_GET_PARTITION_INFO
TODO: 0x70048: FILE_DEVICE_DISK: IOCTL_DISK_GET_PARTITION_INFO_EX
	for format H:

	Done: implement I/O handler stubs
		Stubs done, return STATUS_OK (or STATUS_NOT_IMPLEMENTED)


Later: Try to put I/O on DRBD device.
	This will be the same device as if there was no DRBD (use
	the drive letters).

	Update: Started setting the Active flag automatically from
	within DRBD (currently only at successful attach, later
	also on connect. Somewhere else?).

	Done: Unset the flag on down / detach. Or better set it on
	becoming primary, clear it on becoming secondary (let
	DRBD do the checks).

	Later: Remove check in mvolWrite(): DRBD should do this.

	Update: Currently drbd_open() fails because of some
	auto-promote mechanism that never happens. It seems
	that the synchronisation (wait_event_interruptible()
	and the like) are broken.

	Update: We now try to have a separate Windows device for drbd
	and backing device this is more close to what DRBD under
	Linux does.

---------------

TODO: We should really lock the backing devices using NT kernel
	mechanisms.

TODO: Implement function stubs created when integrating DRBD 9.0.9

TODO: We want to see the syslog output when the system did boot, not
	only when we configure a DRBD device.

TODO: Have a function that initialized all (global) spinlocks
	and replace the racy solution (with an flag indicating
	wheter it is initialized) we have now.

TODO: cond_wait shouldn't busy loop. How is this done in Linux.

TODO: Possible race at drbd_thread_setup() (drbdmain.c:567) with
	use-after-free.

TODO: #ifdef the Windows netlink code in drbd-utils

TODO: Make drbd service stoppable
	This probably takes some while
	Update: with the new architecture that should be possible
	one day.

TODO: Have sshd on Windows and work remotely
	Would be convenient, however setup is a little bit
	complicated ...

TODO: Make drbd run on peer Linux box

Maybe Later: Port agruen's test suite to cygwin.

TODO: fix the macro redefinition problems in drbd_windows.c
	For now we have to copy the function prototypes from MSDN.
	Not good style.

	Update: check if the prototypes are still needed.

TODO: Later: RCU needs change
--------------------------------

Done: fix patch errors on Linux side build (conversion)
	a make clean did solve it

Done: backup on www.johannesthoma.com

Rejected: install Windows kernel headers
	Is part of EWDK.

Rejected: Download heise Linux Virus scanner CD and check image.
	I tried Desinfec't 2014 but it hangs. Now have Avira 
	inside the Windows machine.

	TO DO: This should start automatically at boot

Rejected: Maybe migrate vdi image to internal SSD

Done: Reboot Mac and see if it is still slow
	Done: Something in the VM config was slow, created a new one

Rejected: Install FreeSshD
	
Done: Install cygwin
	Done, works
	Also installed Dev (GNU toolchain)

Done: Install Visual Studio
	C headers are missing, TO DO: Uninstall and redo installation
	from scratch.	
	Done, works now

Rejected: Reorganize converted sources (have drbd and drbd-headers inside
	a dummy dir, to make it compatible to original layout.

Done: Make it compile under Windows
	Done: Fixed permission errors
	Done: Must work with /cygdrive/z/... mapping (cmd.exe does not
		support UNC names)

	Done: path to cl.exe
	Done: install EWDK (plus prerequisites like device driver
		kit)

	Done: make signing the driver work.
	Done: Make clean and remake to see if it still works.

	Must:
	1.) Run 
		make 
	on the Linux box (from $HOME/Linbit/Work/wdrbd9)

	2.) Run
		make
	on the Windows box (from $HOME/Linbit/Work/wdrbd9 (takes some while)

	3.) Run
		make install
	on the Windows box (from $HOME/Linbit/Work/wdrbd9/converted-sources/drbd)

	4.) Run (in an Administrator cmd.exe Console: to open it go to
		 C:\Windows\System32 in Explorer, Cmd-Click on cmd.exe
		 and select Run as Administrator)
		INSTALL-DRBD-admin.bat

	5.) To load the driver, do (from Adminstrator Console)
		sc start drbd
	DbgViewer will show output. To start DbgViewer go to 
	C:\drbd\DebugViewer and start DbgView.exe as Administrator

Done: Revert to original build layout
	Done: Backported work done in converted sources
	Rejected: Cross compiling coccinelle for Linux (requires ocaml)
		Does not work, Ubuntu OCaml parmap library installation
		seems to be broken.
	Done: see if there is a cygwin package for coccinelle
		No
	Rejected: install ocaml for CygWin
	Rejected: Cross compile conccinelle for CygWin
		If possible, do not try to fix too many things.
	Rejected: make should build everything under Windows

Done: make install should install the driver and activate it
	(Rethink: only install the service User should do 
	sc start drbd manually, since that could crash the
	machine rightaway)

Done: make install should also be possible in top make file

Rejected: Migrate sources to Windows C: drive and build from there
	Maybe then it is faster..but then we need to make tarball and
	the like .. Hmmm.

	Rejected because Windows crashes randomly. It is also better
	to have sources on Linux since step 1 of the build has to be
	executed under Linux.

Rejected: Remove everything with signing (signtool exits with an error)
	We leave it in, even though it does not work. Must start Windows
	with Load unsigned drivers (Press F8 at boot and select bottom
	most entry (Load unsigned drivers))

Done: Insmod
	Rejected: pnputil -a drbd.inf
	Done: currently fails with Permission denied.
		Must run cmd.exe as administrator (Cmd-Click on
		cmd.exe in /Windows/System32)
	Done: try if F8 + load unsigned drivers works.
		Yes it does.

Done: Install DRBD Linux peer VM
	Ubuntu Server? Took Ubuntu 16.04 Gnome edition
	Installed drbd from git repo

Done: Add volume to Windows VM for DRBD test drive.

Done: logging: syslog server (see how it is done)
	Currently checking DebugViewer (but doesn't survive blue screen)

Done: Run DRBD with provided config file
	One Windows one Linux peer, with added Volume as backing
	storage.
	However there are many issues, see KNOWN-BUGS

Done: send public key to upstream

Done: Add build instructions to repo

Done: revert (make invisible) last 3 patches from upstream

Done: git pull last commit

Done: rebase dev branch to upstream master

Done: Merge into 

Done: drbd-adm: For now, have two different entries (NT-style, UNIX style)
	have win-disk and win-meta-disk in addition to UNIX style
	disk device paths. 

Done: Reconfigure drbd-utils with sane paths (/usr/local/etc ->
	/etc) 
	Problem is that drbdadm fails because some path does not
	exist.

Done: fix the syslog printk code to print all messages
	At least partially .. print all messages to the local
	Debugging facility (use DbgView.exe to see them), when
	IRQL is higher than DISPATCH we must not sleep and cannot
	send UDP packets. 

Done: Why does DRBD crash when loaded at boot time?
	Because signature is invalid. Boot windows with 
	F8+Allow invalid signatures.

Rejected: kernel: keep track of opened HANDLEs and struct drbd_block_devices
		(but please not in VOLUME_EXTENSIONs they don't belong there)
Rejected: kernel: Use that handle for I/O on backing device
	This is probably too slow. Keep the current device stack
	approach.

Done: kernel: win4lin: see if symlinks work
	We need to resolve them (ZwQuerySymbolicLinkObject), Done

Done: drbdsetup should translate NT-style pathes to NT kernel internal
	style pathes (this is easy)

Done: drbdmeta should accept NT-style pathes
	Problem is that /dev/sda and /dev/sdb is sometimes
	swapped (see KNOWN-BUGS) 

Done: We need to use NT-style I/O functions for drbdmeta
	(ReadFile, WriteFile) in pread/write_or_die()
	and use NtOpenFile() (need to load address
	from NTDLL.DLL).

Done: Open backing device:
	Need to reboot Windows to make it work. Right now I don't see any
	possibilty to attach to the device stack without rebooting
	(maybe pnp manager can be told to reiterate disk devices somehow..)

Done: For some disk sizes, NtReadFile fails with EOF reached
	(0xc0000011)
	Root kit?
	Update: No, seems to be a NTFS kind of hack. With cygwin it
	works. Our version fails on NTFS partitions (which don't contain
	DRBD meta data anyway), so we can work around it.

	We just print a warning and terminate now.

Rejected: Have NTDLL functions in separate file?
	Without knowing struct format internals.
	We are using WIN32 API which is not that wild.

Done: D: -> \\DosDevices\\D: also in drbdmeta
	Done

Done: check if drbd-utils compiles on Linux.
	No it doesn't. Netlink port was unclean (doesn't #ifdef __CYGWIN__)
	takes some time to repair.

Done: Revert the win-disk patch later to use only 
	NT style disk device paths (win-disk becomes disk, UNIX
	disk device paths are not used any more).

	We need to patch drbdmeta for that.
	Update: Patch is there, need to revert and test.
	Reverted and tested.

Done: printk_syslog(): collect the messages in a ring buffer and send them 
	later.
	Nice-to-have, do that later.
	Done it, it is good to have it for further work.

Done: Locking for ring buffer

Done: IRQ message should go before current message.

Done: printk_syslog(): merge logging functions of
	jt/logging-fixed-and-windows-boots-with-signature-check-disabled
	into master and push

Done: IP address of logging host should be configurable (Registry?)

Rejected: fix driver signature
	Don't know how this works..we now use Windows Test Mode to 
	avoid pressing F8 all the time.

Done: integrate INSTALL-DRBD-admin.bat in Makefile.win

Done: Merge changes to master (including drbd_thread_setup non-static)
	and push.

Done: Frees in Completion routine: is the memory freed by lower level
	driver?
	No it is Paged and accessed in an IRQ routine.
	Update: Now returning MORE_PROCESSING_REQUIRED and the
	blue screen disappeared.
	See https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/constraints-on-completion-routines :
		"After calling IoFreeIrp, the completion routine must return STATUS_MORE_PROCESSING_REQUIRED to indicate that no further completion processing is needed."

Done: fix 0x4e blue screen on drbdadm detach / down
	Last message: 
drbd_bm_resize <6>drbd w0/17 minor 26, ds(Diskless), dvflag(0x2000): drbd_bm_resize called with capacity == 0
	
Done: Make it work with DRBD from September

Done: Do we really need all those IOCTLs?
	drbdcon does not exist in WinDRBD, new ioctls are not 
	needed.

Done: use gtest to write tests.
	Probably for some tests where we need to call Windows API functions.
	Maybe we can extent agruen's test suite to call mini binaries.

Done: What we would need is something that overwrites Windows' default
	behaviour of determining device sizes (when Meta data is
	internal we want to report only the payload size without
	the meta data).

	Update: With the new architecture this comes for free.

Done: Have a lower level device for drbdmeta for access of internal
	DRBD meta data while resource is up.
	Update: with new architecture this came for free.

