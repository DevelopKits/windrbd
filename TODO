WinDRBD-next:

TODO: schedule_timeout_interruptible not implemented correctly.

	It just does a wait on single object with a timeout object. so it
	isn't interruptible.

	If solved then also write a small test for it.

TODO: Who is supposed to wake up schedule_timeout_interruptible() in
	dtt_connection_established()?

	Ask phil or lars. Don't want to dig too deep into DRBD now.

	Those two are needed to make connection work.

TODO: Make connection work.
	It seems that kernel_recvmsg() does not receive anything
	from the windrbd side (it fails with an EAGAIN error
	reproducible).
	If DRBD on Linux is replaced by a ncat we can see the
	packets arriving on both sockets: 
ncat -l 7600 -k | hexdump -v
0000000 7483 6702 f1ff 0000 7483 6702 f2ff 0000

	Update: If connection is established in the order
	connect send connect send the first packet is received.

	Done: Write a small C program (with gcc) to test that from user
	mode. 
	It works non-interleaved (is a cygwin program)

	Now, check tcpdump output.
	TCP checksums are wrong but this is most likely due to 
	checksum offloadinng (they are correct on the wire only
	the network card displays it wrong).

	Apart from that the packets seem to be equal (sequence number?)
	Update sequence number is Wireshark connection ID.

	Update: difference is that Linux DRBD upon incoming connection
	tries to reach windrbd which fails because windrbd makes a
	bind but no listen currently. What is strange is that 
	connect() on Linux side succeeds while we see a RST in 
	the TCP packet coming from windrbd (but that is maybe
	because the socket is non-blocking on the Linux side).
	
	We now patch Linux DRBD so that connect(2) always fails and
	see if that works.
	Update: unfortunately this did not fix the error.

	netcat on the windrbd port shows that connection is
	accepted(?) but closed immedieately

	Update: No packets get lost. The initial packets are received
	and the 80 byte handshake packet is sent to windrbd.
	However there it is never received (drbd_recv_short
	is never being called by windrbd). So the whole
	thing was because receiving the handshake packet
	(80 bytes) is not implemented on the windrbd side.

	Rejected: write 2 C (user space) programs that show how this
	scenario looks like in POSIX environment (bind without listen
	and connect returning 0)

TODO: Re-port drbd_transport_tcp.c to windrbd's
	drbd_transport_wtcp.c.
	Update: currently it seems that the problem is
	somewhere else. 
	However we need those updates. Best way would be to
	git diff the original drbd transport_tcp to the version
	we had before and apply the patches manually.

TODO: Right now, windrbd isn't listening for incoming connections.

	Connection should work nevertheless.

--------------------------------------------------------------

TODO: allow user to pass name of symbolic link created
	(i.e. the drive letter) via drbdadm/drbdsetup/kernel

	Update: This should be userspace-only. It should
	also be possible to mount the device upon an
	empty NTFS folder.

	At this point also clean up drbd-utils (separate
	files for UNIX and Windows) and integrate upstream
	changes.

TODO: implement open and close methods.

TODO: Throw away lots of Mantech code.

TODO: Release backing device:
	drbdadm up / drbdadm down / format f:

TODO: Inform windows about new drive.
	So that explorer opens.

TODO: windrbd.exe hide-ntfs-partition

TODO: on patching boot sector, inform Windows that file system is
	raw now.
	So that it disappears.

TODO: read error: Volume dismounted
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 DrbdIoCompletion <4>[0xFFFFFA800131B040] DrbdIoCompletion: I/O failed with error c000026e
	Nov 15 14:42:21 192.168.56.101  U13:22:16.265|0131b040 drbd_report_io_error <4>drbd w0/17 minor 5, ds(UpToDate), dvflag(0x208): local READ IO error sector 0+1 on

TODO: Understand what windows means by mounting / dismounting.

TODO: Test other file systems (FAT, FAT32, ...)

----------------------------------------------------------------------

TODO: Test with Windows 10 (we have to do that anyway some day)

TODO: check out mantech wdrbd and see if it works (and why)

TODO: Port agruen's test suite to cygwin.

TODO: How is sync done? 
	Data appears delayed on backing device (about 10 - 20 
	seconds later).

TODO: lots of more tests (corner cases like reading near the
	end of the device)

TODO: have windrbd-test execute drbdadm as needed.
	This is a nice to have.

TODO: test if loading drbd driver later (not at boot) works.

-----------------------------------------------------------------------

TODO: have a make depend target
	Or at least header file dependencies.

TODO: blkdev_put isn't called on drbdadm down

	fix this one day, this is probably a DRBD9 bug. Or maybe
	it is intentional.

	INIT_WORK and schedule_work do what they say?

	Later: Currently bdput is called from within drbd_unregister_device,
	ask phil if that is ok (it should make the device invisible, which
	is what it does).

	Update: this is something with RCUs

	Update: call_rcu now does something, is this fixed now?

TODO: Check if it is a network share (currently blue screens)
	Update: blue screen was something else. Should check if the
	drive letter is a network share. Unfortunately they do not
	appear in the \DosDevices directory. If we create a drive
	letter (symbolic link) in the \DosDevices it will be silently
	ignored. Warn the user if it is a network share.

TODO: One day we want to have a more specific error message
	than Device does not have a disk config if the device or
	the drive letter already exist.

---------------

TODO: We should really lock the backing devices using NT kernel
	mechanisms.

	Maybe use the mechanically locked IOCTL? Then one would
	have to drbdadm down <res> --force

TODO: Implement function stubs created when integrating DRBD 9.0.9

TODO: We want to see the syslog output when the system did boot, not
	only when we configure a DRBD device.

TODO: Have a function that initialized all (global) spinlocks
	and replace the racy solution (with an flag indicating
	wheter it is initialized) we have now.

TODO: cond_wait shouldn't busy loop. How is this done in Linux.

TODO: Possible race at drbd_thread_setup() (drbdmain.c:567) with
	use-after-free.

TODO: #ifdef the Windows netlink code in drbd-utils

TODO: Make drbd service stoppable
	This probably takes some while
	Update: with the new architecture that should be possible
	one day.

TODO: Have sshd on Windows and work remotely
	Would be convenient, however setup is a little bit
	complicated ...
	This is a nice to have.

TODO: fix the macro redefinition problems in drbd_windows.c
	For now we have to copy the function prototypes from MSDN.
	Not good style.

	Update: check if the prototypes are still needed.
	Update: we probably reject this.

TODO: Later: RCU needs change
	At least call_rcu now calls the function. I don't think
	that it is a good idea to port the linked list thing to
	windows, we want to stay thin..

TODO: The functions enclosed by _WIN32_MVFL (see win4lin/src/util.c) are
	not referenced anywhere in the code. I assume that they never have been
	tested. I would like to remove them (or at least rewrite them if the
	functionality is needed) since they depend on some other stuff I would
	like to redesign.

	Update: We need the functionality if DeviceIoControl() (user level
	function) is called on the DRBD device. So leave it in for now.

	Update: We don't want any DRBD specific DeviceIoControls. Check if
	one of those are really needed and then remove the code.

--------------------------------

Done: fix patch errors on Linux side build (conversion)
	a make clean did solve it

Done: backup on www.johannesthoma.com

Rejected: install Windows kernel headers
	Is part of EWDK.

Rejected: Download heise Linux Virus scanner CD and check image.
	I tried Desinfec't 2014 but it hangs. Now have Avira 
	inside the Windows machine.

	TO DO: This should start automatically at boot

Rejected: Maybe migrate vdi image to internal SSD

Done: Reboot Mac and see if it is still slow
	Done: Something in the VM config was slow, created a new one

Rejected: Install FreeSshD
	
Done: Install cygwin
	Done, works
	Also installed Dev (GNU toolchain)

Done: Install Visual Studio
	C headers are missing, TO DO: Uninstall and redo installation
	from scratch.	
	Done, works now

Rejected: Reorganize converted sources (have drbd and drbd-headers inside
	a dummy dir, to make it compatible to original layout.

Done: Make it compile under Windows
	Done: Fixed permission errors
	Done: Must work with /cygdrive/z/... mapping (cmd.exe does not
		support UNC names)

	Done: path to cl.exe
	Done: install EWDK (plus prerequisites like device driver
		kit)

	Done: make signing the driver work.
	Done: Make clean and remake to see if it still works.

	Must:
	1.) Run 
		make 
	on the Linux box (from $HOME/Linbit/Work/wdrbd9)

	2.) Run
		make
	on the Windows box (from $HOME/Linbit/Work/wdrbd9 (takes some while)

	3.) Run
		make install
	on the Windows box (from $HOME/Linbit/Work/wdrbd9/converted-sources/drbd)

	4.) Run (in an Administrator cmd.exe Console: to open it go to
		 C:\Windows\System32 in Explorer, Cmd-Click on cmd.exe
		 and select Run as Administrator)
		INSTALL-DRBD-admin.bat

	5.) To load the driver, do (from Adminstrator Console)
		sc start drbd
	DbgViewer will show output. To start DbgViewer go to 
	C:\drbd\DebugViewer and start DbgView.exe as Administrator

Done: Revert to original build layout
	Done: Backported work done in converted sources
	Rejected: Cross compiling coccinelle for Linux (requires ocaml)
		Does not work, Ubuntu OCaml parmap library installation
		seems to be broken.
	Done: see if there is a cygwin package for coccinelle
		No
	Rejected: install ocaml for CygWin
	Rejected: Cross compile conccinelle for CygWin
		If possible, do not try to fix too many things.
	Rejected: make should build everything under Windows

Done: make install should install the driver and activate it
	(Rethink: only install the service User should do 
	sc start drbd manually, since that could crash the
	machine rightaway)

Done: make install should also be possible in top make file

Rejected: Migrate sources to Windows C: drive and build from there
	Maybe then it is faster..but then we need to make tarball and
	the like .. Hmmm.

	Rejected because Windows crashes randomly. It is also better
	to have sources on Linux since step 1 of the build has to be
	executed under Linux.

Rejected: Remove everything with signing (signtool exits with an error)
	We leave it in, even though it does not work. Must start Windows
	with Load unsigned drivers (Press F8 at boot and select bottom
	most entry (Load unsigned drivers))

Done: Insmod
	Rejected: pnputil -a drbd.inf
	Done: currently fails with Permission denied.
		Must run cmd.exe as administrator (Cmd-Click on
		cmd.exe in /Windows/System32)
	Done: try if F8 + load unsigned drivers works.
		Yes it does.

Done: Install DRBD Linux peer VM
	Ubuntu Server? Took Ubuntu 16.04 Gnome edition
	Installed drbd from git repo
	Update: we are using the production VM since not enough
	RAM for running 3 VMs.

Done: Add volume to Windows VM for DRBD test drive.

Done: logging: syslog server (see how it is done)
	Currently checking DebugViewer (but doesn't survive blue screen)

Done: Run DRBD with provided config file
	One Windows one Linux peer, with added Volume as backing
	storage.
	However there are many issues, see KNOWN-BUGS

Done: send public key to upstream

Done: Add build instructions to repo

Done: revert (make invisible) last 3 patches from upstream

Done: git pull last commit

Done: rebase dev branch to upstream master

Done: Merge into 

Done: drbd-adm: For now, have two different entries (NT-style, UNIX style)
	have win-disk and win-meta-disk in addition to UNIX style
	disk device paths. 

Done: Reconfigure drbd-utils with sane paths (/usr/local/etc ->
	/etc) 
	Problem is that drbdadm fails because some path does not
	exist.

Done: fix the syslog printk code to print all messages
	At least partially .. print all messages to the local
	Debugging facility (use DbgView.exe to see them), when
	IRQL is higher than DISPATCH we must not sleep and cannot
	send UDP packets. 

Done: Why does DRBD crash when loaded at boot time?
	Because signature is invalid. Boot windows with 
	F8+Allow invalid signatures.

Rejected: kernel: keep track of opened HANDLEs and struct drbd_block_devices
		(but please not in VOLUME_EXTENSIONs they don't belong there)
Rejected: kernel: Use that handle for I/O on backing device
	This is probably too slow. Keep the current device stack
	approach.

Done: kernel: win4lin: see if symlinks work
	We need to resolve them (ZwQuerySymbolicLinkObject), Done

Done: drbdsetup should translate NT-style pathes to NT kernel internal
	style pathes (this is easy)

Done: drbdmeta should accept NT-style pathes
	Problem is that /dev/sda and /dev/sdb is sometimes
	swapped (see KNOWN-BUGS) 

Done: We need to use NT-style I/O functions for drbdmeta
	(ReadFile, WriteFile) in pread/write_or_die()
	and use NtOpenFile() (need to load address
	from NTDLL.DLL).

Done: Open backing device:
	Need to reboot Windows to make it work. Right now I don't see any
	possibilty to attach to the device stack without rebooting
	(maybe pnp manager can be told to reiterate disk devices somehow..)

Done: For some disk sizes, NtReadFile fails with EOF reached
	(0xc0000011)
	Root kit?
	Update: No, seems to be a NTFS kind of hack. With cygwin it
	works. Our version fails on NTFS partitions (which don't contain
	DRBD meta data anyway), so we can work around it.

	We just print a warning and terminate now.

Rejected: Have NTDLL functions in separate file?
	Without knowing struct format internals.
	We are using WIN32 API which is not that wild.

Done: D: -> \\DosDevices\\D: also in drbdmeta
	Done

Done: check if drbd-utils compiles on Linux.
	No it doesn't. Netlink port was unclean (doesn't #ifdef __CYGWIN__)
	takes some time to repair.

Done: Revert the win-disk patch later to use only 
	NT style disk device paths (win-disk becomes disk, UNIX
	disk device paths are not used any more).

	We need to patch drbdmeta for that.
	Update: Patch is there, need to revert and test.
	Reverted and tested.

Done: printk_syslog(): collect the messages in a ring buffer and send them 
	later.
	Nice-to-have, do that later.
	Done it, it is good to have it for further work.

Done: Locking for ring buffer

Done: IRQ message should go before current message.

Done: printk_syslog(): merge logging functions of
	jt/logging-fixed-and-windows-boots-with-signature-check-disabled
	into master and push

Done: IP address of logging host should be configurable (Registry?)

Rejected: fix driver signature
	Don't know how this works..we now use Windows Test Mode to 
	avoid pressing F8 all the time.

Done: integrate INSTALL-DRBD-admin.bat in Makefile.win

Done: Merge changes to master (including drbd_thread_setup non-static)
	and push.

Done: Frees in Completion routine: is the memory freed by lower level
	driver?
	No it is Paged and accessed in an IRQ routine.
	Update: Now returning MORE_PROCESSING_REQUIRED and the
	blue screen disappeared.
	See https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/constraints-on-completion-routines :
		"After calling IoFreeIrp, the completion routine must return STATUS_MORE_PROCESSING_REQUIRED to indicate that no further completion processing is needed."

Done: fix 0x4e blue screen on drbdadm detach / down
	Last message: 
drbd_bm_resize <6>drbd w0/17 minor 26, ds(Diskless), dvflag(0x2000): drbd_bm_resize called with capacity == 0
	
Done: Make it work with DRBD from September

Done: Do we really need all those IOCTLs?
	drbdcon does not exist in WinDRBD, new ioctls are not 
	needed.

Done: use gtest to write tests.
	Probably for some tests where we need to call Windows API functions.
	Maybe we can extent agruen's test suite to call mini binaries.

Done: What we would need is something that overwrites Windows' default
	behaviour of determining device sizes (when Meta data is
	internal we want to report only the payload size without
	the meta data).

	Update: With the new architecture this comes for free.

Done: Have a lower level device for drbdmeta for access of internal
	DRBD meta data while resource is up.
	Update: with new architecture this came for free.

Done: Have other device extension with only the fields we
	need.

	We now disabled mvolAddDevice (by returning NO_SUCH_DEVICE,
	else we blue screen because some verifier) so volume
	extension does not exist any more (except in non-accessible
	code). 

	Update: maybe the struct block_device should be the windows
	device extension, so we safe a intermediate data structure.

	Update: That's what we do now. While having NT kernel internal
	variables inside linux structures seems like bad design at
	first, it saves a lot of (unneccessary) work. For example
	we now have the offset and io_stat used by 
	win_generic_make_request() internally as part of the struct bio.

	Done: Next thing is to have replacment data structure so
	that attach works again (create block_device with target
	device looked up in find_target_dev). Also get I/O on
	that target dev working (used to blue screen but maybe
	it works now that we do not create a device in AddDevice())

	Update: for DRBD devices device extension is now struct
	block_device. 

	Update: after long research (and with help from a stack overflow
	kernel guru) we solved the blue screen and now do not do 
	AddDevices any more.

	Rejected: check if generic_make_request can use the ZwCreateFile
	API (instead of creating an IRP)
		I/O on the backing devices work now (again) with the
		IRP API.

	Done: remove devices in bdput destroyer.
	Implemented but cannot test it now, it is newer called from 
	drbd_destroy_device (which is also never called).
	Update: calling it now from drbd_unregister_device(). Works.

	Done: bdput in drbd_create_device on failure.

	Done: clean up code, delete commented out code.

	Done: size fix (with external meta data something destroys the
	disk size setting, so that drbdadm up / down only works once).
	Update: this doesn't happen no more.

	Done: clean up block devices created by blkdev_get_by_path().

	Done: keep an internal list of struct block_devices created
	for backing devices (so that internal meta data works again).
	and don't have more than one struct block_device per physical
	partition.

	Works now (again) with internal meta data.

Done: Redesign of architecture.

	Currently the DRBD device is stacked atop of the low level
	Disk drivers. This way all I/O goes through the WinDRBD
	driver also that of the non-drbd drives (like C:, ...).
	An Active flag controls whether I/O is routed through
	DRBD or not.
	
	One major drawback is that once the Active flag is set
	we cannot access the lower device. This is needed however
	by drbdmeta.
	
	We want an architecture that is more close to that one
	of Linux where DRBD devices and backing devices are different
	device objects, even for the Windows kernel.


Done: Try to put I/O on DRBD device.
	This will be the same device as if there was no DRBD (use
	the drive letters).

	Update: Started setting the Active flag automatically from
	within DRBD (currently only at successful attach, later
	also on connect. Somewhere else?).

Done: Unset the flag on down / detach. Or better set it on
	becoming primary, clear it on becoming secondary (let
	DRBD do the checks).

Rejected: Remove check in mvolWrite(): DRBD should do this.

	Update: Currently drbd_open() fails because of some
	auto-promote mechanism that never happens. It seems
	that the synchronisation (wait_event_interruptible()
	and the like) are broken.

	Update: We now try to have a separate Windows device for drbd
	and backing device this is more close to what DRBD under
	Linux does.

Done: Create patches for DRBD for recent changes.

Done: README.md

Done: Submit current sources.

Done: make format H: work

Done: Writing partition table should not fail.

Done: Fix sharing violation problem.
	Currently find_windows_device fails (as it should) calling
	IoGetDeviceObjectPointer() (before it can check the list
	of already open backing devices, these are currently indexed
	by exactly that pointer) because close_backing_dev is currently
	not called on detach. The reason is probably that schedule_work()
	mechanism is implemented wrong in windrbd.

	Update: drbd_destroy isn't called because the rcu mechanism
	is not implemented (or not implemented correctly) in windrbd.
	Do that after 0.2

	Update: sharing violation now fixed, however now there is
	an IO ERROR: neither local nor remote data which is new.

	Update: We now shift the backing device by one sector so
	that Windows NT does not recognize the backing device as
	NTFS (or whatever) formatted. This solution works quite
	well for us and also prevents Windows NT from replaying
	journal before the DRBD device is brought up.

Done: Fix IO ERROR
	It seems to come from an 0xc0000022 (access denied) error
	from the lower level device.

	Update: Error was not propagated to user space, this should be
	fixed now.

	Update: error c0000011 on accessing meta data (end of file
	error) when meta data is internal.

	Sectors are now shifted, see sharing violation problem.

Done: where did the volsize blue screen disappear.
	When using IRPs on an NTFS formatted partition, we had
	blue screens which do not happen any more. This is strange.

	Update: Also does not blue screen when meta data is internal,
	however apply-al does not work (error c0000011 (end of file)
	when reading meta data).

	Sectors are now shifted, see sharing violation problem.

Done: when there is NTFS on the backing device drbdadm up fails
	(with internal meta data) because it cannot access meta
	data.

	Plus there is a blue screen when changing from internal
	to external meta data. (This might be a windows internal
	bug tough).

	Update: No it was something else..Irps don't work with
	getting volsize of an NTFS partition, rewrote it to 
	use ZwXXX() API, now we have problems with sharing
	violations.

	Sectors are now shifted, see sharing violation problem.

Done: DeviceControl (there are many more but those
	are the ones called when the device is opened):

Done: implement I/O handler stubs
	Stubs done, return STATUS_OK (or STATUS_NOT_IMPLEMENTED)

Done: nc test
	Works as expected.

Done: Fix Spurious timeout error on receive.
	Was behaving as intended.

Done: hack test

Done: Make drbd run on peer Linux box
	We cannot run 3 VMs on our Macbook Air since it has only
	4 GB of RAM. Now, we are using the production Linux box
	for DRBD peer.

Done: make drbdmeta be able to read near the end of an NTFS 
	partition.
	We now hide NTFS from windows when it is a backing
	device.

Rejected / Partially done: tcpdump nc and drbd and see if there is a difference.
	Didn't find anything yet, however there must be
	something. Look at the packets with hex?

	Update: The packets were received but on the windrbd side
	the 80 byte handshake parameter packet never is received
	(it is sent by Linux DRBD).

